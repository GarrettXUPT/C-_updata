#include<iostream>
#include"Human.h"
#include"Man.h"
#include"wowan.h"

using namespace std;

/*
	一、派生类对象模型简介
		一个子类对象，包含多个组成部分(也就是多个子对象)
		1.一个是含有派生类自己定义的成员变量、成员函数的子对象
		2.一个是所继承的父类的子对象，这个子对象中包含的是基类中所包含的成员变量和成员函数(派生类中含有基类的子对象) 

	二、派生类构造对象
		派生类对象实际是使用基类的构造函数来初始化它的基类部分
		基类控制基类部分的成员初始化，派生类控制派生类的成员初始化

	三、既当父类又当子类
		继承关系一直传递，构成了继承链，最终中间的类会包含它的直接基类所有成员以及每个间接基类所有成员

	四、不想当基类的类
		C++11特性：final关键字加在类名后，该类就不可以被当做基类被使用,若是加在基类的成员函数中，那么该成员函数就不能被重写
		class A final{};
		class B final : public C{}  该类继承了C，但是自己本身不可被继承

	五、静态类型与动态类型
		静态类型：指的是变量声明时候的类型，静态类型编译的时候是已知的
		动态类型：指的是该指针或者引用所代表的内存中对象的类型，动态类型是在运行的时候才可以知道
		动态类型，静态类型这种概念只有基类指针/引用才存在这种静态类型与动态类型不一致的情况

		若不是基类的指针/引用，那么静态类型和动态类型永远都是一致的

	六、派生类向基类的隐式类型转换
		该转换为编译器完成，这种转换之所以能够成功是因为每个派生类对象都包含一个基类对象部分，
		所以基类的指针或者是引用是可以帮到基类对象这部分，基类对象可以独立存在，也可以作为派生类的一种派生类的一部分存在

		并不存在从基类到派生类的自动类型转换，
		编译器是通过静态类型推断转换的合法性

		若基类中有虚函数的话，可以通过dynamic_cast进行转换 
		Man man;
		Human*phuman = &man;
		Man *pman = dynamic_cast<Man*>(phuman);
		if(pan != nullptr) 指的是转换成功的条件


		Human human;
		Man &my = human; (非法)  派生类的引用不能绑到基类上
		Man *pmy = &human; (非法) 不能将基类转换为派生类

		Man man;
		Human *phuman = &man;  // 基类指针绑定派生类对象

	七、父类与子类之间的拷贝与赋值
		Man man;  // 派生类对象
		Human human(man);   // 使用派生类对象来定义并初始化基类对象，这会导致基类的拷贝构造函数的执行
							// Human作为基类，只能处理自己的成员，无法处理派生类的成员
		Man man；
		Human human;
		human = man;

		总结：用派生类对象作为一个基类对象初始化或者赋值时，只有该派生类对象的基类部分会被拷贝或者赋值
			  派生类部分就会被忽略，也就是说，基类只干自己的事情，多余的事情不会被操心





		
*/ 

/*
	基类
*/
class A {
public:
	A(int i):m_value(i) {};  // 就是构造函数的初始化列表
	virtual ~A() {};
private:
	int m_value;
};

/*
	派生类
*/
class B : public A {
public:
	/*
		给基类构造函数传值方式，通过子类的初始化列表，可以给父类的构造函数传递参数 
	*/
	B(int i, int j, int k) : A(i), m_i(i), m_j(j), m_k(k){};
	virtual ~B() {};
private:
	int m_i, m_j, m_k;
};

/*
	示例
*/
void test01() {
	Human* phuman = new Man;  // 基类指针可以指向子类对象的原因是子类对象中含有父类部分
							// 也就是说派生类对象当做基类对象使用，也就是基类指针new一个派生类对象出来，这种类型转换是隐式的
							// 这种转换的好处是：有些需要基类引用(指针)的地方可以用这个派生类对象的引用(指针)代替
							// 传递参数给基类构造函数问题：通过派生类的构造函数初始化列表

	B varB(10, 20, 50);  // 创建对象的时候，先创建基类构造函数，再创建派生类构造函数
					// 释放对象的时候，先释放派生类，再释放基类

	Human* phuman1 = new Man;  // 基类指针指向派生类对象

	Human& q = *phuman1;   // 基类引用绑定到派生类对象上

}

int main() {
	
	return 0;
}
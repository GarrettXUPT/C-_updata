#include<iostream>
#include"Human.h"
#include"Man.h"
#include"wowan.h"

using namespace std;

/*
	一、基类指针、派生类指针

	二、虚函数（调用虚函数，执行的是动态绑定）
		override(用在子类中，虚函数专用)
		为避免在子类中写错虚函数，在C++11中可在函数声明的头文件里增加override关键字，关键字用在子类中，虚函数专用
		使用override重写的函数，必须是与基类中虚函数同名同参
		override就是用来说明派生类中的虚函数，你用了这个关键字以后，编译器就认为你这个eat是覆盖了基类中的虚函数的
		只有虚函数存在子类覆盖父类中同名函数的问题，编译器会找父类中同名同参的虚函数，若没有找到，编译器就会报错

		final(虚函数专用，用在父类中)
		若在父类函数声明中，如果加上final那么任何尝试覆盖该函数的尝试都将引发错误

		动态绑定指的就是在我们程序运行时候才能知道调用哪个子类的虚函数
		动态绑定的对象取决于new的是Man还是Woman，形式是指针
		动态绑定的概念：运行的时候才决定你的phuman对象绑定到那个子类虚函数中

	三、多态性
		多态性只是针对虚函数来说
		随着虚函数概念的提出，面向对象编程思想里面的就产生了多态性
		多态性：体现在具有继承关系的父类和子类之间，子类重新定义父类的成员函数，同时将这个成员函数申明为虚函数
		通过父类的指针，只有到了程序运行时期，找到动态绑定到父类指针上的对象，这个对象有可能是子类对象，也可能是父类对象
		然后系统内部实际上是要查一个虚函数表，找到虚函数的入口地址，从而调用父类或者子类的虚函数，这就是运行时期的多态性

	四、纯虚函数
		纯虚函数是在基类中声明的虚函数，但是在基类中没有定义，但是要求任何子类都要定义该虚函数自己的实现方法
		基类中实现纯虚函数的方法是在函数原型后增加=0

		一旦在类中定义了纯虚函数，那么就不能生成该类对象,这个类就变成了抽象类
		抽象类不能进行实例化对象

		1.含有纯虚函数的类叫做抽象类，不能用来生成对象，主要用于基类生成子类用
		2.子类中必须要实现基类中定义的纯虚函数

	五、基类的析构函数一般写成虚函数
		用基类指针new子类的对象，在delete中，系统不会调用子类的析构函数，此时就说明没有将基类析构函数设置为虚函数
		在public继承中，基类对于派生类及其对象的操作，只能影响到那些从基类继承下来的成员
		若基类想对非继承成员进行操作，则把基类的这个函数设置为虚函数，析构函数自然也是如此
		另外，基类中析构函数的虚属性也会被继承给子类，这样的话子类中的析构函数也就成为了虚函数，虽然名字与基类的析构函数不同

		delete phuman时，肯定是要调用父类的析构函数，但要是在父类析构函数中，他要是想要调用子类man的析构函数，那么
		Human这个类中的析构函数就要声明为虚函数，也就是说在运行时获得多态效果，那么调用的成员函数也不是virtual的

		如果一个类想要做基类，务必要将该类的析构函数写成虚函数，只要基类的析构函数是虚函数，那么就可以保证delete基类指针时能够运行正确的析构函数版本
		
		普通类可以不设置虚析构函数，虚函数是会增加内存开销的
		我们在类中定义虚函数，编译器就会增加虚函数表，在表里存放着虚函数的指针

*/

/*
	类的使用
*/
void test01() {
	/*
		父类, 一旦在类中定义了纯虚函数，那么就不能生成该类对象
	*/
	//Human* phuman = new Human();

	/*
		子类
	*/
	Man* pman = new Man();  // 使用了Human的构造函数  使用了man的构造函数

	Woman* woman = new Woman();  // 使用了Human的构造函数 调用了Woman的构造函数
	//woman->testClass();  // 使用的是Woman类

	/*
		使用父类指针创建子类对象
		父类指针可指向子类对象，父类指针强大

		子类指针是不可以创建/指向父类对象
	*/
	Human* phuman1 = new Man;

	Human* phuman2 = new Woman;

	//Human* human = new Human;
	/*
		父类类型指针可以调用父类的成员函数
		虽然创建的是子类对象，但是确是父类指针，父类指针不可以调用子类的成员函数
		既然不能调用子类的成员函数，那为什么要new一个子类对象呢
	*/
	//phuman1->testHuman();  // 调用的是父类对象

	/*
		父类指向子类对象的指针可使用虚函数来调用子类的方法
	*/
	phuman1->testClass();   // 使用的是Man类
	phuman2->testClass();  // 使用的是Woman类
	//human->testClass();   // 使用的是Human类

	/*
		这么写的话是可以调用父类的虚函数的
	*/
	phuman1->Human::testClass();  // 调用的是Human

	phuman1->eat();	// 男人喜欢吃面食

	//delete phuman;
	delete phuman1;  // 调用了man的析构函数  执行了Human析构函数
	delete phuman2;  // 调用了woman的析构函数  执行了Human析构函数 

	delete pman;  // 调用了man的析构函数  执行了Human析构函数
	delete woman;  // 调用了woman的析构函数  执行了Human析构函数 
}

int main() {
	test01();
	system("pause");
	return 0;
}
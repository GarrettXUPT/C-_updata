#include<iostream>

using namespace std;

/*
	函数模板
	一、概述
		1、泛型编程是以独立于任何特定类型的方式编写的代码，使用泛型编程时，我们需要提供具体程序实例所操作的类习惯或者值
		2、模板是泛型编程的基础，模板是创建类或者函数的蓝图或者是公式。我们给这些公式提供必要的信息，使其真正转变为具体的类或者函数(转变发生在编译时)
		3、模板支持将类型作为参数的程序设计方式，从而实现对泛型程序设计的直接支持，C++允许在定义类或者函数时，将类型作为参数
		模板一般分为：函数模板和类模板

	二、函数模板的定义
		1、模板定义以template关键字开头，后面跟着模板参数列表，若模板参数列表中有多个参数，那么就以逗号分开，模板参数列表中至少要有一个模板参数
		   模板参数列表中既可以是typename也可以是class关键字
		   若模板参数列表中具有多个末班参数，那么就需要使用多个typaname/class
		2、模板参数列表中表示在函数定义中要用到的类型或者是值，也和函数参数列表类似，我们在使用时，有时指定模板实参，指定的时候要使用<>包起来
		   有的时候并不需要模板实参，这时候系统可以根据信息推断出来
		3、funAdd函数声明了名字为T的类型参数，T是类型，编译器在编译时，根据该函数模板的调用就可以确定

	三、函数模板的使用
		函数模板调用和函数调用区别不大，调用的时候，编译器会根据调用该模板时的实参去推断模板参数列表，推断的依据就是根据调用函数时的实参
		当然有时，光凭借提供的函数实参是推断不出来模板参数的，这时候我们就需要使用<>主动提供模板参数
	
	四、非类型模板参数
		上述函数模板typename/class使用的是类型参数
		那么在模板参数列表中还可以定义非类型参数，非类型参数代表的是一个值，那么我们不可以使用typename/class关键字来修饰
		我们要使用以往学习过的传统类型名来指定非类型参数。非类型参数S若是整型，int s,
		当模板被实例化时，非类型模板参数的值 或者是用户提供的，也有可能是编译器推断的，但是这些非类型的模板参数的值必须是常量表达式
		因为实例化这些模板都是咋编译器编译时候实例化的，所以必须是常量表达式

	模板定义时，编译器是不会生成代码的，只有再调用函数模板时，编译器为我们实例化一个特定的版本之后，编译器才会生成代码
	******编译器生成代码时需要能够找到代码的函数体，所以函数模板的定义通常都是在.h文件中******
*/

/*
	函数模板定义(相当于公式或者是样板)
*/
template<typename T>
T funcAdd(T i1, T i2) {
	return i1 + i2;
}

/*
	非类型参数模板
*/
template<int s1, int s2>
int funMul() {
	return s1 + s2;
}

template<unsigned L1, unsigned L2>
int charscomp(const char(&arr1)[L1], const char(&arr2)[L2]) {
	return strcmp(arr1, arr2);
}

/*
	类型模板参数和非类型模板参数混用
	函数模板是可以inline的
*/
template<typename T, int a, int b>
inline T funSub(T c) {
	return a + b - c;
}



/*
	函数模板的使用
	编译器推断出这个模板的形参类型以后，编译器就为我们实例化了一个特定版本的函数int funAdd(int i1, int i2);
*/
void test01() {
	/*
		类型模板的使用,注意使用的类型要统一
	*/
	int sum = funcAdd(3, 1);
	cout << "sum = " << sum << endl;   // 4
	/*
		非类型模板参数,以<>传值，传递的必须是常量表达式，必须是在编译时就可以确定，因为实例化函数模板是在编译时完成的
		显式指定模板参数
	*/
	int mul = funMul<12, 2>();
	cout << "mul = " << mul << endl;  // 24 
	/*
		类型模板参数和非类型模板参数混用，实际使用的时候，以<>显式传递进去的类型为准
	*/
	int sub = funSub<int, 12, 13>(20);
	cout << "sub = " << sub << endl;  // 5

	/*
		数组的使用
		这里系统自动推断数组长度
	*/
	int res = charscomp("test", "test2");
	cout << "res = " << res << endl;  // -1

}

int main() {
	test01();
	return 0;
}
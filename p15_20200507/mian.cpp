#include<iostream>
#include"Time.h"

using namespace std;

/*
	一、重载运算符
		==、>、>= <= != ++ -- += -= + = cout cin << >>、= 赋值运算符
		对象之间的比较可以重载==运算符，重载函数名为operator==,这个成员函数体内，我们要写一些比较逻辑
		重载运算符本质上是一个函数，函数的正式名字 operator关键字+运算符
		重载运算符是一个函数，那么他就有返回函数和参数列表
		有些运算符，我们不自己写运算符的重载，系统会给我们生成一个，例如赋值运算符的重载(拷贝功能)
	
	二、拷贝赋值运算符
		Time time1;
		Time time2 = time1;  // 系统会自动生成
		编译器自动生成的赋值运算符比较粗糙，一般就是将非static成员变量复制到对应的成员上去
		为了精确控制Time类的赋值运算符，我们常常自己写重载赋值运算符
		赋值运算符重载函数的参数就是运算符的运算对象

	三、析构函数
		析构函数与构造函数相对应，在对象销毁时候自动调用
		若我们自己不写析构函数，那么编译器就会生成一个默认析构函数。默认的析构函数没干事
		若在构造函数中new了内存出来，那么我们应该手动在析构函数中将这些内存释放delete

		构造函数的初始化：函数体之前是初始化成员变量，函数体之中进行赋值操作啥的 
		析构函数的作用：函数体之中我们自己释放资源；函数体之后系统接管销毁对象
		成员变量的初始化和销毁的时机问题：
			初始化：初始化时候要用常量，切忌使用成员变量进行相互赋值
			销毁：销毁时先定义的后销毁

		new对象和delete对象：只要new系统就会调用构造函数，若是delete则系统调用析构函数	
*/


/*
	类的使用
*/
void test01() {

	Time time1(11, 11, 11);
	Time time2 = time1;  // 调用了拷贝构造函数
	Time time3(12, 12, 12);
	if (time1 == time2) {
		cout << "两个对象相等" << endl;
	}
	if (time1 == time3) {
		cout << "两个对象相等" << endl;
	}
	else
	{
		cout << "两个对象不相等" << endl;
	}
}
/*
	new来生成对象
*/
void test02() {
	/*
		我们new出来的对象，必须要自己释放，不能指望系统释放，否则就会造成内存泄漏
	*/
	Time* pmytime = new Time(11, 11, 11);  // 11:11:11
	pmytime->printTime();

	/*
		在系统程序运行结束之前，必须使用delete删除对象
	*/
	delete pmytime;
}

int main() {
	test02();
	system("pause");
	return 0;
}
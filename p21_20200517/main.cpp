#include<iostream>
#include<string>

using namespace std;

/*
	一、左值和右值
		int i = 10;  // 将i看做一个对象：对象就是一块内存区域
		左值：可用作赋值语句等号左侧的东西，它会对应内存中的一块地址
		右值：不能作为左值的值就是右值，不能出现在赋值语句等号的左侧
		结论：C++中的一条表达式，要么就是右值，要么就是左值，不可能两者都不是，也不可能两者都是，左值有时可以作为右值进行使用
			i = i + 1 这里的i是左值，只不过是被当做右值来进行使用
					  i出现在左边，用的是i代表的内存中的地址，出现在右边用的是i所代表的值
			  一个左值他可能同时具有左值属性和右值属性，实际上整个赋值语句的结果仍然是左值
		需要用到左值运算符：
			1、赋值运算符
			2、取地址& (变量就是个左值)
			3、容器的下标[]都需要左值，迭代器的自增、自减运算符使用时也是需要左值
			4、通过观察运算符在字面值上能不能操作，若可以操作，就是用到左值
		左值表达式：左值 右值表达式：右值
		左值表达式的求值结果就是一个对象(就得有地址)
		求值结果为对象表达式，不代表一定是左值，具体再分析

	二、引用分类
		引用可以分为三种形式：
			1、左值引用(将一个变量绑定到左值)
			2、const引用(常量引用)我们不希望改变值的对象
			3、右值引用(将变量绑定到右值)

	三、左值引用
		左值引用就是将一个对象绑定到左值上
		引用没有空引用这个说法，所以左值引用在初始化的时候就要绑定左值

	四、右值引用&&：就是引用右值(绑定到右值)，必须是绑定到右值的引用
		希望右值引用绑定到即将销毁或者是临时的对象上
		右值引用也是引用，右值引用可以理解为一个对象的名字

		可以绑定到左值上面的引用，一般不可以绑定到右值
		返回左值引用的函数，连同赋值，下标，解引用和前置递增递减(--i,++i)都是返回左值表达式的例子,我们可以将总之引用绑定到这些结果上
		返回非引用类型的函数，连同算术、关系、位以及后置递增(i--, i++)运算符，都生成右值,不能将左值引用绑定到这类表达式上，
		但是可以将const的左值引用或者右值引用绑定到这类表达式上

		// ++i  左值表达式，++i直接给变量i + 1，然后返回i本身，因为i是变量，所以可以被赋值 
		i = 100;
		(++i) = 199; 此时i就被改变为199

		// i++ 右值表达式 i++先产生一个临时变量(_tempi = i)，记录i的值用于使用的目的，i被使用以后，再给i + 1,接着返回临时变量 
		int i = 1;
		int&& r1 = i++;  成功绑定右值，此后r1的值和i没有关系  
		int& r2 = ++i;  r2绑定到左值上去，r2就为i的别名

		强调：
			1、r1虽然是右值引用，但是r1本身是一个左值(可以将r1看做为一个变量) int& r5 = r1;  此时r5就是r1的别名
			2、所有的变量都要被看做左值，因为他们是有地址的，而且右值引用也绑不上来
			3、任何函数里面的形参都是左值。void f(int&& w) w是右值引用但他的本身是左值
			4、临时对象都是右值
				4.1右值引用的目的：
					1、右值引用是C++11的新概念，&&代表一种新的数据类型
					2、右值引用的目的是提高程序的运行效率，提高的手段就是将拷贝对象变成移动对象来提高程序运算效率
					3、移动对象如何发生。&&(应付移动构造函数，应付移动赋值运算符使用) 移动 & 拷贝
	
	五、std::move函数
		C++11中的新函数，move容易重名，所以在使用时最好带上std
		该函数没有移动操作，他的能力只有一个：将左值强制转化成一个右值,转化过后，右值可以绑上去

	六、左值右值总结：
		
		

*/

/*
	引用分类
*/
void test01() {
	int value = 10;
	/*
		左值引用(将一个变量绑定到左值)
	*/
	int& refval = value;  // refval就是value的别名，这里的&不是取地址的意思，而是起一个标识作用
	cout << "refval change before: " << value << endl;  // 10
	refval = 13;  // 这里就相当于改变了value的值
	cout << "refval change after: " << value << endl;  // 13
	/*
		const引用(常量引用),该处引用的值不能通过refval1改变
	*/
	const int& refval1 = value;
	/*
		右值引用
	*/
	int&& refval2 = 3;  // 该处的3一般是临时的，绑定到一个常数上
}

/*
	左值引用
*/
void test02() {
	int a = 1;
	int& b{ a }; // 将b绑定到a上
	// int& c; 引用一定要初始化
	//int& c = 1 ;  // 左值引用不可以绑定到右值上，必须绑定到左值上
	const int& c = 1;  // 常量引用可以绑定到右值上
						// 此过程就是系统会生成一个临时变量 int tmpvalue = 1;  const int&c = tmpvalue; 
}

/*
	右值引用
*/
void test03() {
	string str = "Walker";
	string& refLstr = str;  // 左值引用绑定左值
	//string& r2 = "Walker";  左值引用不能绑定到临时变量 临时变量被系统当做右值
	const string& r3 = "Walker";  // 可以将临时变量直接绑定到r3上面去，const不但可以绑定到右值，还可执行隐式类型转换
									// 并将所得到的值放到string临时变量上去

	//string&& r4 = str;   // 右值引用不能绑定左值
	string&& r4 = "Garrett";  // 可以绑定一个临时变量，临时变量的内容就是该字符串
	string&& r5 = str + "Garrett";  // 这样是可以绑定到右值上的
	cout << r5 << endl;  // WalkerGarrett

	//string& r6 = str + "Garrett";  // 左值引用不可以往右值上绑 
	const string& r6 = str + " Garrett";  // 常量引用可以绑定到右值上

}

/*
	std::move函数
*/
void test04() {
	int i = 10;
	//int&& r2 = i; // 本来绑定不上
	int&& r2 = std::move(i);  // 这样就绑上了,此时r2就相当于i
	cout << r2 << endl;  // 10
	i = 20;
	cout << r2 << endl;  // 20

	int&& r3 = 60;
	cout << "r3 = " << r3 << endl;  // 60 
	int&& r4 = std::move(r3);
	cout << "r4 = " << r4 << endl;  // 60
	r4 = 80;
	cout << "r4 = " << r4 << endl;  // 80	

	string str = "Garrett";
	string def = std::move(str);  // 此时并不是move将str中的内容移动到了def，而是string类中&&移动构造函数完成的
									// 使用过这样以后，str最好在后面就不要再使用了
	cout << str << endl;  // ""
	cout << def << endl; // "Garrett"
}

int main() {

	test04();
	system("pause");
	return 0;
}
#include<iostream>

using namespace std;

/*
	一、对象移动的概念
		以往都是对象拷贝，在C++11中提出了对象移动
		将对象中有用的数据，移动到有用的地方

	二、移动构造函数和移动赋值运算符
		主要就是为了提高程序运行效率
		移动构造函数：
			引入的目的就是进一步提高程序的效率
		说明：
			1、若是拷贝数据，源对象和目标对象都可以使用，但若是移动数据，那么原对象就不能再使用了
			2、移动的概念不是将内存中的数据从一个地址移动到另外一个地址，这里所说的数据移动其实就是内存数据的所有者变更
		拷贝构造函数
		Time::Time(const Time& tmptime){......}  // const左值引用&
		移动构造函数：
		Time::Time(const Time&& tmptime){......}  // &&右值引用，就是为了实现移动构造函数，解决对象移动
		移动构造函数和移动赋值运算符应该完成的功能：
			1、要完成资源的移动，斩断原对象与该段内存之间的关系
			2、确保移动后原对象处于一种“即便被销毁也没有问题”的状态，确保不再使用原对象
	
	三、移动构造函数举例

	四、移动赋值运算符

	五、合成的移动操作
		某些条件下，编译器可以生成移动构造函数和移动赋值运算符
		1、若一个类定义了自己的拷贝构造函数，拷贝赋值运算符，析构函数，那么编译器就不会为它生成移动构造函数和移动赋值运算符
		   所有有一些类是没有移动构造函数和移动赋值运算符
		2、该类没有提供移动构造函数和移动赋值运算符，编译器会调用拷贝构造函数和拷贝赋值运算符来代替移动构造函数和移动赋值运算符
		3、只有一个类中没有定义任何版本的拷贝构造函数，且类的每个非静态成员都可以移动时，编译器才会为该类合成移动构造函数和移动赋值运算符
		   (成员可移动指的是：1、内置类型是可以移动的  2、类类型的成员，则该类需要有对应的移动操作相关函数，就可以移动)

	六、总结：
		1、尽量各类增加移动构造函数和移动构造运算符；
		2、在移动构造函数和移动赋值运算符最好加上noexpect以增加代码效率
		3、在移动构造函数和移动赋值运算符中，要注意原来对象的处理，需要加上nullptr置空
		4.若类中没有移动构造函数和移动赋值运算符，就使用拷贝相关操作代替
		
*/

class B {
public:
	/*
		默认构造函数
	*/
	B() :m_bm(100) {
		//cout << "类B的构造函数执行了" << endl;
	}
	/*
		拷贝构造函数
	*/
	B(const B& tmp):m_bm(tmp.m_bm) {
		//cout << "类B拷贝构造函数执行了" << endl;
	}

	/*
		析构函数
	*/
	virtual ~B() {
		//cout << "类B的析构函数执行了" << endl;
	}
	int m_bm;
};

class A {
public:
	A():m_pb(new B()){
		cout << "类A的构造函数执行了" << endl;
	}  // 这里会调用B的构造函数
	/*
		拷贝构造函数
	*/
	A(const A& tmpa) :m_pb(new B(*(tmpa.m_pb))) {  // 此处调用类B的拷贝构造函数
		cout << "类A的拷贝构造函数执行了" << endl;
	}
	/*
		析构函数
	*/
	virtual ~A() {
		delete m_pb;
		cout << "类A的析构函数执行了" << endl;
	}

	/*
		移动构造函数，移动构造函数一定要加上noexcept
		noexcept:通知标准库，该移动构造函数不抛出任何异常(提高编译器的效率)
	*/
	A(A&& tmpa) noexcept:m_pb(tmpa.m_pb) {
		/*
			将原对象数据清空
		*/
		tmpa.m_pb = nullptr;
		cout << "类A的移动构造函数执行了" << endl;
	}
	/*
		拷贝赋值运算符
	*/
	A operator=(const A& src) {
		if (this == &src) {
			return *this;
		}
		/*
			先去掉自己的内存
		*/
		delete m_pb;
		/*
			将对方的数据放到自己这里
		*/
		m_pb = new B(*(src.m_pb));
		cout << "类A的拷贝运算符执行了" << endl;
		return*this;
	}
	
	/*
		移动赋值运算符
	*/
	A& operator=(A&& src)noexcept {
		if (this == &src) {
			return*this;
		}
		delete m_pb;
		/*
			指针直接指向对方的内存
		*/
		m_pb = src.m_pb;
		/*
			将原对象的指针置空，以斩断原对象与移动内存的联系
		*/
		src.m_pb = nullptr;
		cout << "类A的移动运算符执行了" << endl;
		return*this;
	}

private:
	B* m_pb;
};

static A getA() {
	A a;
	return a;  // 返回临时对象,调用拷贝构造函数，若在A中定义了移动构造函数，就只调用移动构造函数
}

struct TC
{
	int i;  // 内置类型可移动
	string s;  // string类型中定义了自己的移动操作函数(移动构造函数和移动赋值运算符)
};

/*
	验证可移动类型
*/
void test04() {
	TC a;
	a.i = 100;
	a.s = "Garrett";
	const char* p = a.s.c_str();
	cout << "a.i = " << a.i << " a.s  = " << a.s << "  *p = " << *p << endl;  // a.i = 100 a.s  = Garrett  *p = G
	/*
		此时导致TC使用了系统默认生成的移动构造函数
		string内部的移动构造函数 将a中的支付串移动到了B中
	*/
	TC b = std::move(a);  // 若TC中含有移动构造函数的话，移动构造函数就会执行
	const char* q = b.s.c_str();
	cout << "a.i = " << a.i << " a.s  = " << a.s << "  *p = " << *p << endl;  // a.i = 100 a.s  = Garrett  *p = 
	cout << "b.i = " << b.i << " b.s  = " << b.s << "  *q = " << *q << endl;  // b.i = 100 b.s  = Garrett  *q = G


}


/*
	移动构造函数举例
*/
void test01() {
	B* pb1 = new B;  // new调用类的构造函数
	pb1->m_bm = 19; 

	B* pb2 = new B(*pb1); // 这种给参数的方法，会调用B类的拷贝构造函数

	delete pb1;
	delete pb2;
}

void test02() {
	//A a = getA();  // 现在是一次构造函数，一次移动构造函数，两次析构函数从而整个程序执行完毕
	//A a1(a);   // 会执行一个拷贝构造函数
	/*
		不打算再使用a1，直接调用移动构造函数,此时a1中数据所有权被转移到了a2中，a1不再使用
	*/
	//A a2(std::move(a1));  // 建立了新对象，还调用了新对象a2的移动构造函数
	/*
		这里没有建立新对象，根本不会调用移动构造函数 
		这种操作的效果等同于将对象a2的名字修改为a3，这里的a2和a3指的是同一个对象
		在使用过move以后，最好不要使用a2对象，我们可以使用a3操作a2对象
	*/
	//A&& a3(std::move(a2));
	/*
		相当于从getA返回的临时对象被a4接管
	*/
	A&& a4 = getA();
}

/*
	移动赋值运算符的测试
*/
void test03() {
	A a = getA();
	A a2;  // 普通构造函数
	a2 = std::move(a);  // 这里就会调用a2的移动赋值运算符，这里使用过移动赋值运算符以后，就不要再使用a对象，因为a对象数据已经被转移
}

int main() {
	test04();
	return 0;
}
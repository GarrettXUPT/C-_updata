#include<iostream>
#include"Myvector.h"
#include"Myarray.h"

using namespace std;

/*
	一、概述
		用类模板来实例化一个特定的类
		编译器不能为类模板推断模板参数类型，所以为了使用类模板我们必须在模板名后边用<>来提供额外的模板参数信息
		这些信息就对应着模板参数

	二、类模板定义
		实例化类模板时，必须得有类的全部信息，包括类模板中成员函数的函数体

	三、类模板的成员函数
		要是将类模板成员函数可以写在类模板声明中，对于系统来说，写在类模板定义中的成员函数会被隐式声明为inline函数
		类模板被实例化以后，那么模板的每个实例都会有自己版本的成员函数，所以类模板的成员函数具有和类模板相同的成员参数，类模板的成员函数是有模板参数的
		若要将类模板成员函数的定义(函数体)写在类模板外面，那么成员函数的模板参数就可体现
		定义在类模板之外的成员函数必须以template开始，后面接类模板参数列表，同时在类名后面用<>将模板参数列表中的所有模板参数名列出来
		若是多个模板参数则使用逗号分隔

		实例化的模板，它的成员只有在使用的时候才能被实例化

	四、模板类名字的使用
		在类模板外部可以直接使用类型，但是放在类模板外部，就要加上template<typename T1>

	五、非类型模板参数
		使用限制：
			1、浮点型参数不能做非类型模板参数
			2、类类型也不用做模板参数
*/

/*
	模板类的使用
*/

void test01() {
	/*
		此处的Myvector它是一个类模板名，而不是一个类名
		类模板时实例化类(类型)用的，Myvector<int> 才是类型名，所以实例化的类型总会是用<>包含模板参数
	*/
	Myvector<int> tmpvec;  // 编译器编译至这一行时，编译器就生成了这个具体(完成)的类
}

/*
	非类型模板参数
*/
void test02() {
	MyArray<int, 100> arr1;
	arr1.func();  // 100

	MyArray<int, 10> arr2;
	arr2.func();  // 10
}






int main() {

	test02();
	return 0;
}